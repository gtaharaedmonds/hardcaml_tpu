
let row_bits = data_bits * size
let matrix_bits = row_bits * size
let addr_bits = Int.ceil_log2 size

type 'a t = { buffer : 'a [@bits matrix_bits] } [@@deriving sexp_of, hardcaml]

let init ~f =
  let open Signal in
  let range = List.range 0 size in
  let buffer =
    List.map range ~f:(fun row -> List.map range ~f:(fun col -> f row col))
    |> List.concat |> concat_lsb
  in
  { buffer }

let _select_from_constants t row col =
  let open Signal in
  let offset = (row * row_bits) + (col * data_bits) in
  select t (offset + data_bits - 1) offset

(* barrel shifter for selecting an element from a constant row *)
module Select_from_row = struct
  module I = struct
    type 'a t = { col : 'a [@bits addr_bits] } [@@deriving hardcaml]
  end

  module O = struct
    type 'a t = { out : 'a [@bits data_bits] } [@@deriving hardcaml]
  end

  let create (t : 'a t) ~row (i : _ I.t) =
    let open Signal in
    let row_buffer =
      select t.buffer (((row + 1) * row_bits) - 1) (row * row_bits)
    in
    let out =
      mux i.col
        (List.init size ~f:(fun col ->
             select row_buffer (((col + 1) * data_bits) - 1) (col * data_bits)))
    in
    { O.out }

  let testbench () =
    let test_row row =
      let module Sim = Cyclesim.With_interface (I) (O) in
      let t =
        init ~f:(fun row col ->
            Signal.of_int ~width:data_bits ((row * size) + col))
      in
      let sim = Sim.create (create t ~row) in
      let waves, sim = Waveform.create sim in
      let i = Cyclesim.inputs sim in
      let cycle () = Cyclesim.cycle sim in
      i.col := Bits.of_int ~width:addr_bits 0;
      cycle ();
      i.col := Bits.of_int ~width:addr_bits 1;
      cycle ();
      i.col := Bits.of_int ~width:addr_bits 2;
      cycle ();
      Stdio.print_endline ("Row #" ^ Int.to_string row);
      Waveform.print waves ~display_width:40 ~display_height:8
    in
    test_row 0;
    test_row 1;
    test_row 2
end

(* barrel shifter for selecting an element from a constant column *)
module Select_from_col = struct
  module I = struct
    type 'a t = { row : 'a [@bits addr_bits] } [@@deriving hardcaml]
  end

  module O = struct
    type 'a t = { out : 'a [@bits data_bits] } [@@deriving hardcaml]
  end

  let create (t : 'a t) ~col (i : _ I.t) =
    let open Signal in
    let col_buffer =
      List.init size ~f:(fun row ->
          let offset = (row * row_bits) + (col * data_bits) in
          select t.buffer (offset + data_bits - 1) offset)
      |> concat_lsb
    in
    let out =
      mux i.row
        (List.init size ~f:(fun row ->
             select col_buffer (((row + 1) * data_bits) - 1) (row * data_bits)))
    in
    { O.out }

  let testbench () =
    let test_col col =
      let module Sim = Cyclesim.With_interface (I) (O) in
      let t =
        init ~f:(fun row col ->
            Signal.of_int ~width:data_bits ((row * size) + col))
      in
      let sim = Sim.create (create t ~col) in
      let waves, sim = Waveform.create sim in
      let i = Cyclesim.inputs sim in
      let cycle () = Cyclesim.cycle sim in
      i.row := Bits.of_int ~width:addr_bits 0;
      cycle ();
      i.row := Bits.of_int ~width:addr_bits 1;
      cycle ();
      i.row := Bits.of_int ~width:addr_bits 2;
      cycle ();
      Stdio.print_endline ("Col #" ^ Int.to_string col);
      Waveform.print waves ~display_width:40 ~display_height:8
    in
    test_col 0;
    test_col 1;
    test_col 2
end



let%expect_test "select_from_row_testbench" =
  Select_from_row.testbench ();
  [%expect
    {|
  Row #0
  ┌Signals─┐┌Waves───────────────────────┐
  │        ││────────┬───────┬───────    │
  │col     ││ 0      │1      │2          │
  │        ││────────┴───────┴───────    │
  │        ││────────┬───────┬───────    │
  │out     ││ 00     │01     │02         │
  │        ││────────┴───────┴───────    │
  └────────┘└────────────────────────────┘
  Row #1
  ┌Signals─┐┌Waves───────────────────────┐
  │        ││────────┬───────┬───────    │
  │col     ││ 0      │1      │2          │
  │        ││────────┴───────┴───────    │
  │        ││────────┬───────┬───────    │
  │out     ││ 03     │04     │05         │
  │        ││────────┴───────┴───────    │
  └────────┘└────────────────────────────┘
  Row #2
  ┌Signals─┐┌Waves───────────────────────┐
  │        ││────────┬───────┬───────    │
  │col     ││ 0      │1      │2          │
  │        ││────────┴───────┴───────    │
  │        ││────────┬───────┬───────    │
  │out     ││ 06     │07     │08         │
  │        ││────────┴───────┴───────    │
  └────────┘└────────────────────────────┘
  |}]

let%expect_test "select_from_col_testbench" =
  Select_from_col.testbench ();
  [%expect
    {|
  Col #0
  ┌Signals─┐┌Waves───────────────────────┐
  │        ││────────┬───────┬───────    │
  │row     ││ 0      │1      │2          │
  │        ││────────┴───────┴───────    │
  │        ││────────┬───────┬───────    │
  │out     ││ 00     │03     │06         │
  │        ││────────┴───────┴───────    │
  └────────┘└────────────────────────────┘
  Col #1
  ┌Signals─┐┌Waves───────────────────────┐
  │        ││────────┬───────┬───────    │
  │row     ││ 0      │1      │2          │
  │        ││────────┴───────┴───────    │
  │        ││────────┬───────┬───────    │
  │out     ││ 01     │04     │07         │
  │        ││────────┴───────┴───────    │
  └────────┘└────────────────────────────┘
  Col #2
  ┌Signals─┐┌Waves───────────────────────┐
  │        ││────────┬───────┬───────    │
  │row     ││ 0      │1      │2          │
  │        ││────────┴───────┴───────    │
  │        ││────────┬───────┬───────    │
  │out     ││ 02     │05     │08         │
  │        ││────────┴───────┴───────    │
  └────────┘└────────────────────────────┘
  |}]
